#!/bin/sh
#
# CIP Core, generic profile
#
# Copyright (c) Siemens AG, 2024
#
# Authors:
#  Quirin Gylstorff <quirin.gylstorff@siemens.com>
#
# SPDX-License-Identifier: MIT

prereqs()
{
	# Make sure that this script is run last in local-top
	local req
	for req in "${0%/*}"/*; do
		script="${req##*/}"
		if [ "$script" != "${0##*/}" ]; then
			printf '%s\n' "$script"
		fi
	done
}
case $1 in
prereqs)
	prereqs
	exit 0
	;;
esac

. /scripts/functions

# get configuration variables
. /usr/share/encrypt_partition/encrypt_partition.env

mount_partition() {
	partition_dev_path=$1
	partition_mountpoint=$2
	echo "mount device: '$partition_dev_path' to '$partition_mountpoint'"
	if ! mountpoint -q "${partition_mountpoint}"; then
		if ! mount -t "$(get_fstype "${partition_dev_path}")" "${partition_dev_path}" \
			 "${partition_mountpoint}"; then
			panic "Can't mount partition '${partition_dev_path}'!"
		fi
	fi
}
partition_sets="$PARTITIONS"
for partition_set in $partition_sets; do
	partition="$(awk -v var="$partition_set" 'BEGIN{split(var,a,":"); print a[1]}')"
	partition_mountpoint="$(awk -v var="$partition_set" 'BEGIN{split(var,a,":"); print a[2]}')"
	case "$partition" in
		/*)
			part_device=$(readlink -f "$partition")
			crypt_mount_name="$( basename "$partition")"
			;;
		*)
			if uuidparse "$partition" -n -o TYPE | grep -q invalid; then
				part_device=$(readlink -f /dev/disk/by-partlabel/"$partition")
				crypt_mount_name="encrypted_${partition}"
			else
				part_device=$(readlink -f /dev/disk/by-partuuid/"$partition")
				crypt_mount_name="${partition}"
			fi
			;;
	esac
	decrypted_part=/dev/mapper/"$crypt_mount_name"
	if [ -z "$partition_mountpoint" ]; then
		continue
	fi
	if /usr/sbin/cryptsetup luksDump --batch-mode "$part_device" \
			| grep -q "luks2"; then
		mount_partition "$decrypted_part" "${rootmnt}""$partition_mountpoint"
	else
		mount_partition "$part_device" "$rootmnt""$partition_mountpoint"
	fi
done
