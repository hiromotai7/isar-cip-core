#!/bin/sh
#
# CIP Core, generic profile
#
# Copyright (c) Siemens AG, 2023-2024
#
# Authors:
#  Quirin Gylstorff <quirin.gylstorff@siemens.com>
#
# SPDX-License-Identifier: MIT

prereqs()
{
	# Make sure that this script is run last in local-top
	# If the abroofs or verity hooks are installed, this script
	# should still come after them.
	local req
	for req in "${0%/*}"/*; do
		script="${req##*/}"
		if [ "$script" != "${0##*/}" ] &&
		   [ "$script" != "abrootfs" ] && [ "$script" != "verity" ] &&
		   [ "$script" != "cryptroot" ]; then
			printf '%s\n' "$script"
		fi
	done
}
case $1 in
prereqs)
	prereqs
	exit 0
	;;
esac

. /scripts/functions

# get configuration variables
. /usr/share/encrypt_partition/encrypt_partition.env

# get the implementation
. /usr/share/encrypt_partition/encrypt_partition_tpm2
# load necessary kernel modules:
modprobe tpm_tis
modprobe tpm_crb

modprobe ecb
modprobe aes_generic
modprobe xts

# this needs to be probed particularly for re-encryption
modprobe loop

partition_sets="$PARTITIONS"
create_file_system_cmd="$CREATE_FILE_SYSTEM_CMD"
pcr_bank_hash_type="$HASH_TYPE"
tpm_key_algorithm="$KEY_ALGORITHM"
tpm_encryption_optional="$ENCRYPTION_IS_OPTIONAL"
if [ -z "${create_file_system_cmd}" ]; then
	create_file_system_cmd="mke2fs -t ext4"
fi

service_watchdog() {
	for n in $(seq $(($SETUP_TIMEOUT / 10)) ); do
		printf '\0'
		sleep 10
	done > "$WATCHDOG_DEV"
}

reencrypt_existing_partition() {
	part_size_blocks="$(cat /sys/class/block/"${1##*/}"/size)"
	# reduce the filesystem and partition by 32M to fit the LUKS header
	partition_fstype=$(get_fstype "${1}")
	reduce_device_size=32768
	reduced_size="$(expr "$part_size_blocks" - 65536 )"
	reduced_size_in_byte="$(expr "$reduced_size" \* 512)"
	reduced_size_in_kb="$(expr "$reduced_size_in_byte" / 1024)K"
	case $partition_fstype in
	ext*)
		# reduce the filesystem and partition by 32M to fit the LUKS header
		e2fsck -p -f "$1"
		if ! resize2fs "$1" "${reduced_size_in_kb}"; then
			panic "reencryption of partition $1 cannot continue - resizing of the partition failed!"
		fi
		;;
	btrfs)
		mkdir /.mnt-tmp
		mount -t btrfs "$1" /.mnt-tmp
		btrfs filesystem resize "${reduced_size_in_kb}" /.mnt-tmp
		umount /.mnt-tmp
		rmdir /.mnt-tmp
		;;
	squashfs|swap|erofs|"")
		[ "$debug" = "y" ] && echo "skip disk resize as it is not supported or unnecessary for fstype: '$partition_fstype'"
		;;
	*)
		panic "cannot resize partition, unsupported fstype: '$partition_fstype'"
		;;
	esac
	if [ -x /usr/sbin/cryptsetup-reencrypt ]; then
		/usr/sbin/cryptsetup-reencrypt --new --reduce-device-size "$reduce_device_size"k "$1" < "$2"
	else
		/usr/sbin/cryptsetup reencrypt --encrypt --reduce-device-size "$reduce_device_size"k "$1" < "$2"
	fi
}

expand_partition() {
	key_file="$2"

	boot_device="$(echo "${part_device}" | sed 's/p\?[0-9]*$//')"
	last_part="$(sfdisk -d "${boot_device}" 2>/dev/null | \
		     tail -1 | cut -d ' ' -f 1)"
	if [ "$last_part" != "$1" ]; then
		log_warning_msg "To be expanded partition is not last - skipping expansion"
		return
	fi

	buffer_size=32768
	boot_device_name=${boot_device##*/}
	disk_size="$(cat /sys/class/block/"${boot_device_name}"/size)"
	all_parts_size=0
	for partition in /sys/class/block/"${boot_device_name}"/"${boot_device_name}"*; do
		part_size=$(cat "${partition}"/size)
		all_parts_size=$((all_parts_size + part_size))
	done

	minimal_size=$((all_parts_size + buffer_size))
	if [ "$disk_size" -lt "$minimal_size" ]; then
		return
	fi

	log_begin_msg "Expanding partition $last_part"

	is_gpt="$(sfdisk -d "${boot_device}" 2>/dev/null | grep -q "label: gpt" \
		  && echo 1 || echo 0)"
	if [ "$is_gpt" = "1" ]; then
		dd if="${boot_device}" of=/tmp/__mbr__.bak count=1 >/dev/null 2>&1
	fi

	# Transform the partition table as follows:
	#
	# - Remove any 'last-lba' header so sfdisk uses the entire available
	#   space.
	# - If this partition table is MBR and an extended partition container
	#   (EBR) exists, we assume this needs to be expanded as well; remove
	#   its size field so sfdisk expands it.
	# - For the previously fetched last partition, also remove the size
	#   field so sfdisk expands it.
	sfdisk -d "${boot_device}" 2>/dev/null | \
		grep -v last-lba | \
		sed 's|^\(.*, \)size=[^,]*, \(type=[f5]\)$|\1\2|' | \
		sed 's|^\('"${last_part}"' .*, \)size=[^,]*, |\1|' | \
		sfdisk --force "${boot_device}" >/dev/null 2>&1

	if [ "$is_gpt" = "1" ]; then
		dd if=/tmp/__mbr__.bak of="${boot_device}" >/dev/null 2>&1
		rm /tmp/__mbr__.bak
	fi

	# Inform the kernel about the partitioning change
	partx -u "${last_part}"

	last_part_device_name=${last_part#\/dev/}

	mapping_name=$(cat /sys/class/block/"$last_part_device_name"/holders/*/dm/name)
	# systemd based systems do not need to have the
	# key_file provided since systemd backend for 
	# cryptsetup resolves the passphrase directly
	cat $key_file | cryptsetup resize "$mapping_name"

	last_part_mapped=/dev/mapper/"$mapping_name"
	fs_type=$(get_fstype ${last_part_mapped})

	case ${fs_type} in
	ext*)
		resize2fs "${last_part_mapped}"
		;;
	btrfs)
		mkdir /.mnt-tmp
		mount -t btrfs "${last_part_mapped}" /.mnt-tmp
		btrfs filesystem resize max /.mnt-tmp
		umount /.mnt-tmp
		rmdir /.mnt-tmp
		;;
	*)
		log_warning_msg "Unrecognized filesystem type ${fs_type} - no resize performed"
		;;
	esac

	log_end_msg
}

for candidate in /dev/tpm*; do
	if [ -x /usr/bin/tpm2_pcrread ]; then
		if ! tpm2_pcrread -T device:"$candidate" "$pcr_bank_hash_type":7 --quiet ; then
			continue
		fi
	elif [ -x /usr/bin/tpm2_pcrlist ]; then
		export TPM2TOOLS_DEVICE_FILE="$candidate"
		if ! tpm2_pcrlist -L "$pcr_bank_hash_type":7 > /dev/null; then
			continue
		fi
	fi
	# Debian buster does not have tpm_testparms
	if [ -x /usr/bin/tpm2_testparms ]; then
		if ! tpm2_testparms -T device:"$candidate" "$tpm_key_algorithm" --quiet; then
			continue
		fi
	fi
	tpm_device=$candidate
done

if [ ! -e "$tpm_device" ]; then
	if [ "$tpm_encryption_optional" = "true" ]; then
		log_warning_msg "No tpm_device exists abort optional encryption"
		exit 0
	fi
	panic "No tpm device exists or supports pcr_hash '$pcr_bank_hash_type' or '$tpm_key_algorithm' - cannot create a encrypted device!"
fi

prepare_for_encryption

for partition_set in $partition_sets; do
	partition="$(awk -v var="$partition_set" 'BEGIN{split(var,a,":"); print a[1]}')"
	partition_mountpoint="$(awk -v var="$partition_set" 'BEGIN{split(var,a,":"); print a[2]}')"
	partition_format="$(awk -v var="$partition_set" 'BEGIN{split(var,a,":"); print a[3]}')"
	partition_expand="$(awk -v var="$partition_set" 'BEGIN{split(var,a,":"); print a[4]}')"
	case "$partition" in
		/*)
			part_device=$(readlink -f "$partition")
			crypt_mount_name="$( basename "$partition")"
			;;
		*)
			if uuidparse "$partition" -n -o TYPE | grep -q invalid; then
				part_device=$(readlink -f /dev/disk/by-partlabel/"$partition")
				crypt_mount_name="encrypted_${partition}"
			else
				part_device=$(readlink -f /dev/disk/by-partuuid/"$partition")
				crypt_mount_name="${partition}"
			fi
			;;
	esac
	if [ ! -e  "$part_device" ]; then
		panic "Could not find device  mapped to '$partition' cannot be encrypted!"
	fi
	decrypted_part=/dev/mapper/"$crypt_mount_name"
	# check if we are trying to mount root
	if [ "$partition_mountpoint" = "/" ]; then
		echo "ROOT=$decrypted_part" >/conf/param.conf
	fi

	if /usr/sbin/cryptsetup luksDump --batch-mode "$part_device" \
			| grep -q "luks2"; then
		open_tpm2_partition "$part_device" "$crypt_mount_name" "$tpm_device"
		continue
	fi

	# service watchdog in the background during lengthy re-encryption
	if [ -z "$watchdog_pid" ]; then
		service_watchdog &
		watchdog_pid=$!
	fi

	# create random password for initial encryption
	# this will be dropped after reboot
	tmp_key=/tmp/"$(basename "$part_device")-lukskey"
	openssl rand -base64 32 > "$tmp_key"

	case "${partition_format}" in
		"reencrypt")
			log_begin_msg "Encryption of ${part_device}"
			reencrypt_existing_partition "$part_device" "$tmp_key"
			enroll_tpm2_token "$part_device" "$tmp_key" "$tpm_device" "$tpm_key_algorithm" "$pcr_bank_hash_type"
			open_tpm2_partition "$part_device" "$crypt_mount_name" "$tpm_device"
			log_end_msg
		;;
		"format")
			log_begin_msg "Encryption of ${part_device}"
			/usr/sbin/cryptsetup luksFormat --batch-mode \
				 --type luks2 "$part_device" < "$tmp_key"
			enroll_tpm2_token "$part_device" "$tmp_key" "$tpm_device" "$tpm_key_algorithm" "$pcr_bank_hash_type"
			open_tpm2_partition "$part_device" "$crypt_mount_name" "$tpm_device"
			eval "${create_file_system_cmd} ${decrypted_part}"
			log_end_msg
		;;
		*)
			panic "Unknown value ${partition_format}. Cannot create a encrypted partition !"
		;;
	esac

	if [ "$partition_expand" = "expand" ]; then
		expand_partition $part_device $tmp_key
	fi

	finalize_tpm2_encryption "$part_device"
done

if [ -n "$watchdog_pid" ]; then
	kill "$watchdog_pid"
fi
